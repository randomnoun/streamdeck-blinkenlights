<!DOCTYPE HTML>
<html>

<head>
	<title>com.randomnoun.blinken</title>
	<meta charset="utf-8" />
</head>

<body>
	<script src="js/timers.js"></script>
	<script>

		var websocket = null;
		var pluginUUID = null;
		var settingsCache = {};

		// need a timer per context probably. or not.

		var timo = null;
		var tc = 0;
		
		var DestinationEnum = Object.freeze({ "HARDWARE_AND_SOFTWARE": 0, "HARDWARE_ONLY": 1, "SOFTWARE_ONLY": 2 })

		var blinkenAction = {

			type: "com.randomnoun.blinken.action",

			onKeyDown: function (context, settings, coordinates, userDesiredState) {
			},

			onKeyUp: function (context, settings, coordinates, userDesiredState) {
				/*
				console.log('onKeyUp ', coordinates, 'settings', settings);
				var keyPressCounter = 0;
				if (settings != null && settings.hasOwnProperty('keyPressCounter')) {
					keyPressCounter = settings["keyPressCounter"];
				}

				keyPressCounter++;
				keyPressCounter = keyPressCounter % 10;

				updatedSettings = {};
				updatedSettings["keyPressCounter"] = keyPressCounter;
				settingsCache[context] = updatedSettings;

				this.SetSettings(context, updatedSettings);

				this.SetTitle(context, keyPressCounter);
				*/
			},

			onWillAppear: function (context, settings, coordinates) {
				/*
				var keyPressCounter = 0;
				if (settings != null && settings.hasOwnProperty('keyPressCounter')) {
					keyPressCounter = settings["keyPressCounter"];
				}
				*/
				
				// sequence is 10 frames of animation that we're going to repeat constantly
				var sequence = [];
				for (var i=0; i<10; i++) {
					sequence.push(Math.floor(Math.random() * 6));
				}
				settingsCache[context] = { 'sequence' : sequence };
				
				this.SetTitle(context, "");
				

				if (timo) {
			        console.log('onWillAppear clearing timeout...', timo);
			        clearInterval(timo);
			        timo = null;
			    } 

		        timo = setInterval(() => this.Tick(context, settings, coordinates, 'timeout'), 1500);
		        console.log('--- new timeout...', timo);

			},

			onWillDisappear: function (context, settings, coordinates) {
				if (timo) {
			        console.log('onWillDisappear clearing timeout...', timo);
			        clearInterval(timo);
			        timo = null;
			    } 
				delete settingsCache[context];
				

			},

			// coordinates are {column:n, row:n} 0-based
			// same context is used for all buttons maybe ?
			// so timo only runs on one button at a time at the mo
			// and the state isn't being saved properly
			// each button has its own context though which is a uuid-y string eg 5218E62487F76E38CA9FFADDAB7E37E3

			Tick: function (context, settings, coordinates, extra) {
				// same as onKeyUp for now
				console.log('Tick ', coordinates, 'settings', settings, 'tc', tc, 'settingsCache', settingsCache);

				tc++;
				tc = tc % 10;
				
				var images = ['bg1', 'bg2', 'bg3', 'bg4', 'bg5', 'bg6'];
				// var imageName = images [ tc % 3 ];

				// not sure where the @2x.png images coming to play here. maybe loadImageAsDataUri handles that
				// doesn't look like it though
				for (const [key, value] of Object.entries(settingsCache)) {
  					console.log(key, value);
  					// settingsCache[context] = { 'keyPressCounter': keyPressCounter, 'sequence' : sequence };
  					var _context = key;
  					var imageIdx = value.sequence[tc];
  					var imageName = images[imageIdx];
  					
					loadImageAsDataUri(_context, `${imageName}.png`, function (_context, imgUrl) {
						var json = {
							"event": "setImage",
							"context": _context,
							"payload": {
								image: imgUrl || "",
								target: DestinationEnum.HARDWARE_AND_SOFTWARE
							}
						};
						console.log(JSON.stringify(json));
						websocket.send(JSON.stringify(json));
					})
				}

				// this.SetTitle(context, tc);
			},


			SetTitle: function (context, keyPressCounter) {
				var json = {
					"event": "setTitle",
					"context": context,
					"payload": {
						"title": "" + keyPressCounter,
						"target": DestinationEnum.HARDWARE_AND_SOFTWARE
					}
				};

				websocket.send(JSON.stringify(json));
			},

			SetSettings: function (context, settings) {
				var json = {
					"event": "setSettings",
					"context": context,
					"payload": settings
				};

				websocket.send(JSON.stringify(json));
			},

			AddToSettings: function (context, newSettings) {
				settingsCache[context]
			}
		};

		function connectElgatoStreamDeckSocket(inPort, inPluginUUID, inRegisterEvent, inInfo) {
			pluginUUID = inPluginUUID

			// Open the web socket
			websocket = new WebSocket("ws://localhost:" + inPort);

			function registerPlugin(inPluginUUID) {
				var json = {
					"event": inRegisterEvent,
					"uuid": inPluginUUID
				};

				websocket.send(JSON.stringify(json));
			};

			websocket.onopen = function () {
				// WebSocket is connected, send message
				registerPlugin(pluginUUID);
			};

			websocket.onmessage = function (evt) {
				// Received message from Stream Deck
				var jsonObj = JSON.parse(evt.data);
				var event = jsonObj['event'];
				var action = jsonObj['action'];
				var context = jsonObj['context'];
				var jsonPayload = jsonObj['payload'] || {};

				if (event == "keyDown") {
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					var userDesiredState = jsonPayload['userDesiredState'];
					blinkenAction.onKeyDown(context, settings, coordinates, userDesiredState);
				}
				else if (event == "keyUp") {
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					var userDesiredState = jsonPayload['userDesiredState'];
					blinkenAction.onKeyUp(context, settings, coordinates, userDesiredState);
				}
				else if (event == "willAppear") {
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					blinkenAction.onWillAppear(context, settings, coordinates);
				}
				else if (event == "willDisappear") {
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					blinkenAction.onWillDisappear(context, settings, coordinates);
				}
				else if (event == "sendToPlugin") {

					if (jsonPayload.hasOwnProperty('setValue')) {

						// var newValue = jsonPayload.setValue;
						// blinkenAction.SetSettings(context, { "keyPressCounter": newValue });
						// blinkenAction.SetTitle(context, newValue);

					}

					if (jsonPayload.hasOwnProperty('background-image')) {

						const imageName = jsonPayload['background-image'];

						loadImageAsDataUri(`${imageName}.png`, function (imgUrl) {
							var json = {
								"event": "setImage",
								"context": context,
								"payload": {
									image: imgUrl || "",
									target: DestinationEnum.HARDWARE_AND_SOFTWARE
								}
							};
							websocket.send(JSON.stringify(json));
						})

					}
				}
			};

			websocket.onclose = function () {
				// Websocket is closed
			};
		};


		function loadImageAsDataUri(context, url, callback) {
			var image = new Image();

			image.onload = function () {
				var canvas = document.createElement("canvas");

				canvas.width = this.naturalWidth;
				canvas.height = this.naturalHeight;

				var ctx = canvas.getContext("2d");
				ctx.drawImage(this, 0, 0);
				callback(context, canvas.toDataURL("image/png"));
			};

			image.src = url;
		};

	</script>

</body>

</html>
